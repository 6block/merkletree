<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `merkle_light` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, merkle_light">

    <title>merkle_light - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Crate merkle_light</p><div class="block items"><ul><li><a href="#modules">Modules</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'merkle_light', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>merkle_light</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/merkle_light/lib.rs.html#1-175' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>light <em>Merkle Tree</em> implementation.</p>

<p>Merkle tree (MT) implemented as a full binary tree allocated as a vec
of statically sized hashes to give hashes more locality. MT specialized
to the extent of hashing algorithm and hash item, compatible to the
<code>std::hash::Hasher</code> and supports custom hash algorithms.
Implementation does not depend on any external crypto libraries,
and tries to be as performant, as possible.</p>

<p>This tree implementation uses encoding scheme as in <em>Certificate Transparency</em>
<a href="https://tools.ietf.org/html/rfc6962">RFC 6962</a>:</p>

<pre><code class="language-text">MTH({d(0)}) = ALG(0x00 || d(0)).
For n &gt; 1, let k be the largest power of two smaller than n (i.e.,
k &lt; n &lt;= 2k).  The Merkle tree Hash of an n-element list D[n] is then
defined recursively as
MTH(D[n]) = ALG(0x01 || MTH(D[0:k]) || MTH(D[k:n])),
</code></pre>

<p>Link: <a href="https://en.wikipedia.org/wiki/Merkle_tree"></a></p>

<h1 id='implementation-choices' class='section-header'><a href='#implementation-choices'>Implementation choices</a></h1>
<p>Main idea was that the whole code must obtain specialization at compile
time, hashes must be fixed size arrays known at compile time, hash algorithm
must be interface (lib should not dep on crypto libs) and lib must somehow
mimic std Rust api.</p>

<p>Standard way in Rust is to hash objects with a <code>std::hash::Hasher</code>, and mainly
that is the reason behind the choice of the abstractions:</p>

<p><code>Object : Hashable&lt;H&gt; -&gt; Hasher + Algorithm &lt;- Merkle Tree</code></p>

<p>Custom [<code>merkle::hash::Hashable</code>] trait allows implementations differ
from [<code>std::collection</code>] related hashes, different implementations for
different hashing algorithms / schemas and conforms object-safety trait rules.</p>

<p>[<code>Algorithm</code>] complements [<code>Hasher</code>] to be reusable and follows the idea
that the result hash is a mapping of the data stream.</p>

<p>[<code>Algorithm.hash</code>] had to change its signature to be <code>&amp;mut self</code> (<code>&amp;self</code>) because
most of the cryptographic digest algorithms breaks current state on finalization
into unusable. <code>ring</code> libra tho contains interfaces incompatible to
<code>start-update-finish-reset</code> lifecycle. It requires either <code>cloning()</code> its state
on finalization, or <code>Cell</code>-ing via unsafe.</p>

<h1 id='interface' class='section-header'><a href='#interface'>Interface</a></h1>
<pre><code class="language-text">- build_tree (items) -&gt; tree
- get_root -&gt; hash
- gen_proof -&gt; proof
- validate_proof (proof, leaf, root) -&gt; bool
</code></pre>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>[<code>test_sip.rs</code>]: algorithm implementation example for std sip hasher, u64 hash items
[<code>test_xor128.rs</code>]: custom hash example xor128
[<code>test_cmh.rs</code>]: custom merkle hasher implementation example
[<code>crypto_bitcoin_mt.rs</code>]: bitcoin merkle tree using crypto lib
[<code>crypto_chaincore_mt.rs</code>]: chain core merkle tree using crypto lib
[<code>ring_bitcoin_mt.rs</code>]: bitcoin merkle tree using ring lib</p>

<h1 id='quick-start' class='section-header'><a href='#quick-start'>Quick start</a></h1>
<pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;chaincore&quot;</span>)]</span>

<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">crypto</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">merkle_light</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fmt</span>;
    <span class="kw">use</span> <span class="ident">std</span>::<span class="ident">hash</span>::<span class="ident">Hasher</span>;
    <span class="kw">use</span> <span class="ident">merkle_light</span>::<span class="ident">hash</span>::{<span class="ident">Algorithm</span>, <span class="ident">Hashable</span>};
    <span class="kw">use</span> <span class="ident">merkle_light</span>::<span class="ident">merkle</span>::<span class="ident">MerkleTree</span>;
    <span class="kw">use</span> <span class="ident">crypto</span>::<span class="ident">sha3</span>::{<span class="ident">Sha3</span>, <span class="ident">Sha3Mode</span>};
    <span class="kw">use</span> <span class="ident">crypto</span>::<span class="ident">digest</span>::<span class="ident">Digest</span>;

    <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>)]</span>
    <span class="kw">struct</span> <span class="ident">ExampleAlgorithm</span>(<span class="ident">Sha3</span>);

    <span class="kw">impl</span> <span class="ident">ExampleAlgorithm</span> {
        <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-&gt;</span> <span class="ident">ExampleAlgorithm</span> {
            <span class="ident">ExampleAlgorithm</span>(<span class="ident">Sha3</span>::<span class="ident">new</span>(<span class="ident">Sha3Mode</span>::<span class="ident">Sha3_256</span>))
        }
    }

    <span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">ExampleAlgorithm</span> {
        <span class="kw">fn</span> <span class="ident">default</span>() <span class="op">-&gt;</span> <span class="ident">ExampleAlgorithm</span> {
            <span class="ident">ExampleAlgorithm</span>::<span class="ident">new</span>()
        }
    }

    <span class="kw">impl</span> <span class="ident">Hasher</span> <span class="kw">for</span> <span class="ident">ExampleAlgorithm</span> {
        <span class="attribute">#[<span class="ident">inline</span>]</span>
        <span class="kw">fn</span> <span class="ident">write</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">msg</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) {
            <span class="self">self</span>.<span class="number">0</span>.<span class="ident">input</span>(<span class="ident">msg</span>)
        }

        <span class="attribute">#[<span class="ident">inline</span>]</span>
        <span class="kw">fn</span> <span class="ident">finish</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u64</span> {
            <span class="number">0</span>
        }
    }

    <span class="kw">impl</span> <span class="ident">Hashable</span><span class="op">&lt;</span><span class="ident">ExampleAlgorithm</span><span class="op">&gt;</span> <span class="kw">for</span> [<span class="ident">u8</span>; <span class="number">32</span>] {
        <span class="kw">fn</span> <span class="ident">hash</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">state</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ExampleAlgorithm</span>) {
            <span class="ident">state</span>.<span class="ident">write</span>(<span class="self">self</span>.<span class="ident">as_ref</span>())
        }
    }

    <span class="kw">impl</span> <span class="ident">Algorithm</span><span class="op">&lt;</span>[<span class="ident">u8</span>; <span class="number">32</span>]<span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">ExampleAlgorithm</span> {
        <span class="kw">fn</span> <span class="ident">hash</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) <span class="op">-&gt;</span> [<span class="ident">u8</span>; <span class="number">32</span>] {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">h</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">32</span>];
            <span class="self">self</span>.<span class="number">0</span>.<span class="ident">result</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">h</span>);
            <span class="ident">h</span>
        }

        <span class="kw">fn</span> <span class="ident">reset</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
            <span class="self">self</span>.<span class="number">0</span>.<span class="ident">reset</span>();
        }

        <span class="kw">fn</span> <span class="ident">write_t</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">i</span>: [<span class="ident">u8</span>; <span class="number">32</span>]) {
            <span class="self">self</span>.<span class="number">0</span>.<span class="ident">input</span>(<span class="ident">i</span>.<span class="ident">as_ref</span>());
        }
    }

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">h1</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">32</span>];
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">h2</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">32</span>];
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">h3</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">32</span>];
    <span class="ident">h1</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">0x11</span>;
    <span class="ident">h2</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">0x22</span>;
    <span class="ident">h3</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">0x33</span>;

    <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="ident">MerkleTree</span>::<span class="ident">from_iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="ident">h1</span>, <span class="ident">h2</span>, <span class="ident">h3</span>], <span class="ident">ExampleAlgorithm</span>::<span class="ident">new</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">t</span>.<span class="ident">root</span>());
}</pre>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="mod" href="hash/index.html"
                                  title='mod merkle_light::hash'>hash</a></td>
                           <td class='docblock-short'>
                                <p>Hash infrastructure for items in Merkle tree.
Hash infrastructure for items in Merkle Tree.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="merkle/index.html"
                                  title='mod merkle_light::merkle'>merkle</a></td>
                           <td class='docblock-short'>
                                <p>Merkle tree abstractions, implementation and algorithms.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="proof/index.html"
                                  title='mod merkle_light::proof'>proof</a></td>
                           <td class='docblock-short'>
                                <p>Merkle tree inclusion proof</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>↑</dt>
                    <dd>Move up in search results</dd>
                    <dt>↓</dt>
                    <dd>Move down in search results</dd>
                    <dt>↹</dt>
                    <dd>Switch tab</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt style="width:31px;">+ / -</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "merkle_light";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>